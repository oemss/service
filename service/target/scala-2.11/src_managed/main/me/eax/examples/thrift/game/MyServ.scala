/**
 * Generated by Scrooge
 *   version: 3.16.3
 *   rev: b8593c83072d94fc44feaa8d97940b9266d84ed0
 *   built at: 20140806-054445
 */
package me.eax.examples.thrift.game

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait MyServ[+MM[_]] extends ThriftService {
  
  def add(idR: String, idT: String): MM[Unit]
  
  def delete(idR: String, idT: String): MM[Unit]
  
  def listT(idR: String): MM[Unit]
  
  def listR(lstT: Seq[String] = Seq[String]()): MM[Unit]
  
  def put(where: Short): MM[Unit]
}


object MyServ {
  
  object add$args extends ThriftStructCodec3[add$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("add_args")
    val IdRField = new TField("idR", TType.STRING, 1)
    val IdRFieldManifest = implicitly[Manifest[String]]
    val IdTField = new TField("idT", TType.STRING, 2)
    val IdTFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IdRField,
        false,
        IdRFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        IdTField,
        false,
        IdTFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: add$args) {
    }
  
    override def encode(_item: add$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): add$args = {
      var idR: String = null
      var idT: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  idR = readIdRValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'idR' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  idT = readIdTValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'idT' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new add$args(
        idR,
        idT,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      idR: String,
      idT: String
    ): add$args =
      new add$args(
        idR,
        idT
      )
  
    def unapply(_item: add$args): Option[scala.Product2[String, String]] = Some(_item)
  
  
    private def readIdRValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeIdRField(idR_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdRField)
      writeIdRValue(idR_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdRValue(idR_item: String, _oprot: TProtocol) {
      _oprot.writeString(idR_item)
    }
  
    private def readIdTValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeIdTField(idT_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdTField)
      writeIdTValue(idT_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdTValue(idT_item: String, _oprot: TProtocol) {
      _oprot.writeString(idT_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class add$args(
      val idR: String,
      val idT: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[String, String]
    with java.io.Serializable
  {
    import add$args._
      def this(
        idR: String,
        idT: String
      ) = this(
        idR,
        idT,
        Map.empty
      )
  
    def _1 = idR
    def _2 = idT
  
  
    override def write(_oprot: TProtocol) {
      add$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (idR ne null) writeIdRField(idR, _oprot)
      if (idT ne null) writeIdTField(idT, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      idR: String = this.idR,
      idT: String = this.idT,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): add$args =
      new add$args(
        idR,
        idT,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[add$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[add$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.idR
      case 1 => this.idT
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "add$args"
  }
  
  object add$result extends ThriftStructCodec3[add$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("add_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: add$result) {
    }
  
    override def encode(_item: add$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): add$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new add$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): add$result =
      new add$result(
      )
  
    def unapply(_item: add$result): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class add$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import add$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      add$result.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): add$result =
      new add$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[add$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[add$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "add$result"
  }
  
  object delete$args extends ThriftStructCodec3[delete$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("delete_args")
    val IdRField = new TField("idR", TType.STRING, 1)
    val IdRFieldManifest = implicitly[Manifest[String]]
    val IdTField = new TField("idT", TType.STRING, 2)
    val IdTFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IdRField,
        false,
        IdRFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        IdTField,
        false,
        IdTFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: delete$args) {
    }
  
    override def encode(_item: delete$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): delete$args = {
      var idR: String = null
      var idT: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  idR = readIdRValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'idR' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  idT = readIdTValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'idT' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new delete$args(
        idR,
        idT,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      idR: String,
      idT: String
    ): delete$args =
      new delete$args(
        idR,
        idT
      )
  
    def unapply(_item: delete$args): Option[scala.Product2[String, String]] = Some(_item)
  
  
    private def readIdRValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeIdRField(idR_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdRField)
      writeIdRValue(idR_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdRValue(idR_item: String, _oprot: TProtocol) {
      _oprot.writeString(idR_item)
    }
  
    private def readIdTValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeIdTField(idT_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdTField)
      writeIdTValue(idT_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdTValue(idT_item: String, _oprot: TProtocol) {
      _oprot.writeString(idT_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class delete$args(
      val idR: String,
      val idT: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[String, String]
    with java.io.Serializable
  {
    import delete$args._
      def this(
        idR: String,
        idT: String
      ) = this(
        idR,
        idT,
        Map.empty
      )
  
    def _1 = idR
    def _2 = idT
  
  
    override def write(_oprot: TProtocol) {
      delete$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (idR ne null) writeIdRField(idR, _oprot)
      if (idT ne null) writeIdTField(idT, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      idR: String = this.idR,
      idT: String = this.idT,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): delete$args =
      new delete$args(
        idR,
        idT,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[delete$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[delete$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.idR
      case 1 => this.idT
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "delete$args"
  }
  
  object delete$result extends ThriftStructCodec3[delete$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("delete_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: delete$result) {
    }
  
    override def encode(_item: delete$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): delete$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new delete$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): delete$result =
      new delete$result(
      )
  
    def unapply(_item: delete$result): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class delete$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import delete$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      delete$result.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): delete$result =
      new delete$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[delete$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[delete$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "delete$result"
  }
  
  object listT$args extends ThriftStructCodec3[listT$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("listT_args")
    val IdRField = new TField("idR", TType.STRING, 1)
    val IdRFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IdRField,
        false,
        IdRFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: listT$args) {
    }
  
    override def encode(_item: listT$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): listT$args = {
      var idR: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  idR = readIdRValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'idR' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new listT$args(
        idR,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      idR: String
    ): listT$args =
      new listT$args(
        idR
      )
  
    def unapply(_item: listT$args): Option[String] = Some(_item.idR)
  
  
    private def readIdRValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeIdRField(idR_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdRField)
      writeIdRValue(idR_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdRValue(idR_item: String, _oprot: TProtocol) {
      _oprot.writeString(idR_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class listT$args(
      val idR: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[String]
    with java.io.Serializable
  {
    import listT$args._
      def this(
        idR: String
      ) = this(
        idR,
        Map.empty
      )
  
    def _1 = idR
  
  
    override def write(_oprot: TProtocol) {
      listT$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (idR ne null) writeIdRField(idR, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      idR: String = this.idR,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): listT$args =
      new listT$args(
        idR,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[listT$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[listT$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.idR
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "listT$args"
  }
  
  object listT$result extends ThriftStructCodec3[listT$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("listT_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: listT$result) {
    }
  
    override def encode(_item: listT$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): listT$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new listT$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): listT$result =
      new listT$result(
      )
  
    def unapply(_item: listT$result): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class listT$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import listT$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      listT$result.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): listT$result =
      new listT$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[listT$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[listT$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "listT$result"
  }
  
  object listR$args extends ThriftStructCodec3[listR$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("listR_args")
    val LstTField = new TField("lstT", TType.LIST, 1)
    val LstTFieldManifest = implicitly[Manifest[Seq[String]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        LstTField,
        false,
        LstTFieldManifest,
        None,
        Some(implicitly[Manifest[String]]),
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: listR$args) {
    }
  
    override def encode(_item: listR$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): listR$args = {
      var lstT: Seq[String] = Seq[String]()
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.LIST => {
                  lstT = readLstTValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.LIST
            
                  throw new TProtocolException(
                    "Received wrong type for field 'lstT' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new listR$args(
        lstT,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      lstT: Seq[String] = Seq[String]()
    ): listR$args =
      new listR$args(
        lstT
      )
  
    def unapply(_item: listR$args): Option[Seq[String]] = Some(_item.lstT)
  
  
    private def readLstTValue(_iprot: TProtocol): Seq[String] = {
      val _list = _iprot.readListBegin()
      if (_list.size == 0) {
        _iprot.readListEnd()
        Nil
      } else {
        val _rv = new mutable$ArrayBuffer[String](_list.size)
        var _i = 0
        while (_i < _list.size) {
          _rv += {
              _iprot.readString()
  
          }
          _i += 1
        }
        _iprot.readListEnd()
        _rv
      }
    }
  
    private def writeLstTField(lstT_item: Seq[String], _oprot: TProtocol) {
      _oprot.writeFieldBegin(LstTField)
      writeLstTValue(lstT_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeLstTValue(lstT_item: Seq[String], _oprot: TProtocol) {
      _oprot.writeListBegin(new TList(TType.STRING, lstT_item.size))
      lstT_item.foreach { lstT_item_element =>
        _oprot.writeString(lstT_item_element)
      }
      _oprot.writeListEnd()
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class listR$args(
      val lstT: Seq[String],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Seq[String]]
    with java.io.Serializable
  {
    import listR$args._
      def this(
        lstT: Seq[String] = Seq[String]()
      ) = this(
        lstT,
        Map.empty
      )
  
    def _1 = lstT
  
  
    override def write(_oprot: TProtocol) {
      listR$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (lstT ne null) writeLstTField(lstT, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      lstT: Seq[String] = this.lstT,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): listR$args =
      new listR$args(
        lstT,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[listR$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[listR$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.lstT
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "listR$args"
  }
  
  object listR$result extends ThriftStructCodec3[listR$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("listR_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: listR$result) {
    }
  
    override def encode(_item: listR$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): listR$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new listR$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): listR$result =
      new listR$result(
      )
  
    def unapply(_item: listR$result): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class listR$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import listR$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      listR$result.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): listR$result =
      new listR$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[listR$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[listR$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "listR$result"
  }
  
  object put$args extends ThriftStructCodec3[put$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("put_args")
    val WhereField = new TField("where", TType.I16, 1)
    val WhereFieldManifest = implicitly[Manifest[Short]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        WhereField,
        false,
        WhereFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: put$args) {
    }
  
    override def encode(_item: put$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): put$args = {
      var where: Short = 0
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.I16 => {
                  where = readWhereValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.I16
            
                  throw new TProtocolException(
                    "Received wrong type for field 'where' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new put$args(
        where,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      where: Short
    ): put$args =
      new put$args(
        where
      )
  
    def unapply(_item: put$args): Option[Short] = Some(_item.where)
  
  
    private def readWhereValue(_iprot: TProtocol): Short = {
      _iprot.readI16()
    }
  
    private def writeWhereField(where_item: Short, _oprot: TProtocol) {
      _oprot.writeFieldBegin(WhereField)
      writeWhereValue(where_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeWhereValue(where_item: Short, _oprot: TProtocol) {
      _oprot.writeI16(where_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class put$args(
      val where: Short,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Short]
    with java.io.Serializable
  {
    import put$args._
      def this(
        where: Short
      ) = this(
        where,
        Map.empty
      )
  
    def _1 = where
  
  
    override def write(_oprot: TProtocol) {
      put$args.validate(this)
      _oprot.writeStructBegin(Struct)
      writeWhereField(where, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      where: Short = this.where,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): put$args =
      new put$args(
        where,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[put$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[put$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.where
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "put$args"
  }
  
  object put$result extends ThriftStructCodec3[put$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("put_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: put$result) {
    }
  
    override def encode(_item: put$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): put$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new put$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): put$result =
      new put$result(
      )
  
    def unapply(_item: put$result): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class put$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import put$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      put$result.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): put$result =
      new put$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[put$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[put$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "put$result"
  }

  import com.twitter.util.Future

  trait FutureIface extends  MyServ[Future] {
    
    def add(idR: String, idT: String): Future[Unit]
    
    def delete(idR: String, idT: String): Future[Unit]
    
    def listT(idR: String): Future[Unit]
    
    def listR(lstT: Seq[String] = Seq[String]()): Future[Unit]
    
    def put(where: Short): Future[Unit]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends MyServ$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends MyServ$FinagleService(
      iface,
      protocolFactory)
}